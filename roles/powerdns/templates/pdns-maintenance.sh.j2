#!/bin/bash
# PowerDNS Maintenance Script - Generated by Ansible

set -euo pipefail

# Configuration
DB_NAME="{{ powerdns_db_name }}"
DB_USER="{{ powerdns_db_user }}"
DB_HOST="{{ powerdns_db_host }}"
BACKUP_DIR="{{ powerdns_backup_dir }}"
CONFIG_FILE="{{ powerdns_config_file }}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

info() { echo -e "${BLUE}[INFO]${NC} $1"; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1"; }
banner() { echo -e "${CYAN}[MAINT]${NC} $1"; }

# MySQL query
mysql_query() {
    local query="$1"
    mysql -h "$DB_HOST" -u "$DB_USER" -p"{{ powerdns_db_password }}" -D "$DB_NAME" -sN -e "$query"
}

# Show usage
show_usage() {
    cat << EOF
PowerDNS Maintenance Tool

Usage: $0 <command> [options]

Commands:
    cleanup-logs        Clean up old log files
    optimize-db         Optimize database tables
    check-config        Validate configuration
    restart-service     Restart PowerDNS service
    update-serials      Update all zone serials
    cleanup-backups     Clean up old backup files
    vacuum-db           Vacuum and analyze database
    check-zones         Check all zones for issues
    repair-permissions  Fix file permissions
    full-maintenance    Run all maintenance tasks
    help               Show this help

Options:
    --dry-run          Show what would be done without executing
    --force            Skip confirmation prompts
    --verbose          Show detailed output

Examples:
    $0 cleanup-logs
    $0 optimize-db --dry-run
    $0 full-maintenance --force

EOF
}

# Clean up log files
cleanup_logs() {
    local dry_run="${1:-false}"
    
    banner "=== Log Cleanup ==="
    
    # Find old log files
    local log_files=$(find /var/log -name "*.log*" -type f -mtime +30 2>/dev/null | grep -E "(powerdns|pdns)" || echo "")
    
    if [[ -z "$log_files" ]]; then
        info "No old log files found"
        return 0
    fi
    
    info "Found old log files:"
    echo "$log_files"
    
    if [[ "$dry_run" == "true" ]]; then
        info "DRY RUN: Would delete $(echo "$log_files" | wc -l) log files"
        return 0
    fi
    
    # Delete old log files
    echo "$log_files" | xargs rm -f
    success "Cleaned up old log files"
    
    # Rotate current logs
    if command -v logrotate &>/dev/null; then
        logrotate -f /etc/logrotate.d/powerdns 2>/dev/null || true
        info "Rotated current log files"
    fi
}

# Optimize database
optimize_db() {
    local dry_run="${1:-false}"
    
    banner "=== Database Optimization ==="
    
    if [[ "$dry_run" == "true" ]]; then
        info "DRY RUN: Would optimize database tables"
        mysql_query "SELECT table_name, data_length, index_length FROM information_schema.tables WHERE table_schema = '$DB_NAME';"
        return 0
    fi
    
    info "Optimizing database tables..."
    
    # Get table list
    local tables=$(mysql_query "SHOW TABLES;")
    
    for table in $tables; do
        info "Optimizing table: $table"
        mysql_query "OPTIMIZE TABLE $table;" >/dev/null
    done
    
    success "Database optimization completed"
    
    # Show table statistics
    info "Table statistics after optimization:"
    mysql_query "
        SELECT 
            table_name,
            ROUND(data_length/1024/1024, 2) as 'Data MB',
            ROUND(index_length/1024/1024, 2) as 'Index MB'
        FROM information_schema.tables 
        WHERE table_schema = '$DB_NAME'
        ORDER BY (data_length + index_length) DESC;
    " | while IFS=$'\t' read -r table data_mb index_mb; do
        printf "  %-20s: Data %6s MB, Index %6s MB\n" "$table" "$data_mb" "$index_mb"
    done
}

# Check configuration
check_config() {
    banner "=== Configuration Check ==="
    
    # Check config file syntax
    if pdns_server --config-check 2>/dev/null; then
        success "Configuration syntax is valid"
    else
        error "Configuration syntax check failed"
        return 1
    fi
    
    # Check file permissions
    local config_perms=$(stat -c %a "$CONFIG_FILE" 2>/dev/null || echo "000")
    if [[ "$config_perms" == "640" ]]; then
        success "Configuration file permissions are correct (640)"
    else
        warning "Configuration file permissions: $config_perms (should be 640)"
    fi
    
    # Check database connectivity
    if mysql_query "SELECT 1;" >/dev/null 2>&1; then
        success "Database connectivity is working"
    else
        error "Database connectivity failed"
        return 1
    fi
    
    # Check required directories
    local dirs=("{{ powerdns_config_dir }}" "$BACKUP_DIR" "/var/lib/powerdns" "/var/log/powerdns")
    for dir in "${dirs[@]}"; do
        if [[ -d "$dir" ]]; then
            success "Directory exists: $dir"
        else
            warning "Directory missing: $dir"
        fi
    done
}

# Restart service
restart_service() {
    local force="${1:-false}"
    
    banner "=== Service Restart ==="
    
    if [[ "$force" != "true" ]]; then
        warning "This will restart the PowerDNS service"
        read -p "Continue? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            info "Operation cancelled"
            return 0
        fi
    fi
    
    info "Restarting PowerDNS service..."
    
    if systemctl restart pdns; then
        success "PowerDNS service restarted successfully"
        
        # Wait for service to be ready
        sleep 5
        
        if systemctl is-active --quiet pdns; then
            success "Service is running and healthy"
        else
            error "Service failed to start properly"
            return 1
        fi
    else
        error "Failed to restart PowerDNS service"
        return 1
    fi
}

# Update zone serials
update_serials() {
    local dry_run="${1:-false}"
    
    banner "=== Zone Serial Update ==="
    
    local new_serial=$(date +%Y%m%d%H)
    local zones=$(mysql_query "SELECT name FROM domains WHERE type = 'NATIVE';")
    
    if [[ -z "$zones" ]]; then
        info "No native zones found"
        return 0
    fi
    
    info "Updating serials for native zones to: $new_serial"
    
    if [[ "$dry_run" == "true" ]]; then
        info "DRY RUN: Would update $(echo "$zones" | wc -l) zone serials"
        echo "$zones"
        return 0
    fi
    
    local updated=0
    for zone in $zones; do
        mysql_query "
            UPDATE records r 
            JOIN domains d ON r.domain_id = d.id 
            SET r.content = CONCAT(
                SUBSTRING_INDEX(r.content, ' ', 2), 
                ' $new_serial ', 
                SUBSTRING(r.content, LOCATE(' ', r.content, LOCATE(' ', r.content, LOCATE(' ', r.content) + 1) + 1) + 1)
            )
            WHERE d.name = '$zone' AND r.type = 'SOA';
        "
        ((updated++))
        info "Updated serial for: $zone"
    done
    
    success "Updated $updated zone serials"
}

# Clean up backups
cleanup_backups() {
    local dry_run="${1:-false}"
    local retention_days="{{ backup_config.retention_days | default(30) }}"
    
    banner "=== Backup Cleanup ==="
    
    if [[ ! -d "$BACKUP_DIR" ]]; then
        warning "Backup directory does not exist: $BACKUP_DIR"
        return 0
    fi
    
    # Find old backup files
    local old_backups=$(find "$BACKUP_DIR" -name "powerdns_backup_*" -type f -mtime +$retention_days 2>/dev/null || echo "")
    
    if [[ -z "$old_backups" ]]; then
        info "No old backup files found (retention: $retention_days days)"
        return 0
    fi
    
    info "Found old backup files (older than $retention_days days):"
    echo "$old_backups"
    
    if [[ "$dry_run" == "true" ]]; then
        info "DRY RUN: Would delete $(echo "$old_backups" | wc -l) backup files"
        return 0
    fi
    
    # Delete old backups
    echo "$old_backups" | xargs rm -f
    success "Cleaned up old backup files"
    
    # Show current backup status
    local current_backups=$(ls -1 "$BACKUP_DIR"/powerdns_backup_* 2>/dev/null | wc -l || echo "0")
    local backup_size=$(du -sh "$BACKUP_DIR" 2>/dev/null | cut -f1 || echo "unknown")
    info "Current backups: $current_backups files, total size: $backup_size"
}

# Vacuum database
vacuum_db() {
    local dry_run="${1:-false}"
    
    banner "=== Database Vacuum ==="
    
    if [[ "$dry_run" == "true" ]]; then
        info "DRY RUN: Would analyze and optimize database"
        return 0
    fi
    
    info "Analyzing database tables..."
    
    # Get table list
    local tables=$(mysql_query "SHOW TABLES;")
    
    for table in $tables; do
        info "Analyzing table: $table"
        mysql_query "ANALYZE TABLE $table;" >/dev/null
    done
    
    success "Database analysis completed"
    
    # Update table statistics
    mysql_query "FLUSH TABLES;" >/dev/null
    info "Table statistics updated"
}

# Check zones for issues
check_zones() {
    banner "=== Zone Health Check ==="
    
    local issues=0
    
    # Check for zones without SOA
    local no_soa=$(mysql_query "
        SELECT d.name 
        FROM domains d 
        LEFT JOIN records r ON d.id = r.domain_id AND r.type = 'SOA' 
        WHERE r.id IS NULL AND d.type = 'NATIVE';
    ")
    
    if [[ -n "$no_soa" ]]; then
        error "Zones without SOA records:"
        echo "$no_soa"
        ((issues++))
    else
        success "All native zones have SOA records"
    fi
    
    # Check for zones without NS
    local no_ns=$(mysql_query "
        SELECT d.name 
        FROM domains d 
        LEFT JOIN records r ON d.id = r.domain_id AND r.type = 'NS' 
        WHERE r.id IS NULL AND d.type = 'NATIVE';
    ")
    
    if [[ -n "$no_ns" ]]; then
        error "Zones without NS records:"
        echo "$no_ns"
        ((issues++))
    else
        success "All native zones have NS records"
    fi
    
    # Check for duplicate records
    local duplicates=$(mysql_query "
        SELECT name, type, content, COUNT(*) as count
        FROM records 
        GROUP BY name, type, content 
        HAVING COUNT(*) > 1;
    ")
    
    if [[ -n "$duplicates" ]]; then
        warning "Duplicate records found:"
        echo "$duplicates"
        ((issues++))
    else
        success "No duplicate records found"
    fi
    
    if [[ $issues -eq 0 ]]; then
        success "Zone health check passed"
    else
        warning "Found $issues zone issues"
    fi
    
    return $issues
}

# Fix file permissions
repair_permissions() {
    local dry_run="${1:-false}"
    
    banner "=== Permission Repair ==="
    
    local files_to_fix=(
        "$CONFIG_FILE:640:root:{{ powerdns_group }}"
        "{{ powerdns_config_dir }}:755:root:{{ powerdns_group }}"
        "$BACKUP_DIR:750:root:{{ powerdns_group }}"
        "/var/lib/powerdns:755:{{ powerdns_user }}:{{ powerdns_group }}"
        "/var/log/powerdns:755:{{ powerdns_user }}:{{ powerdns_group }}"
    )
    
    for item in "${files_to_fix[@]}"; do
        IFS=':' read -r path perms owner group <<< "$item"
        
        if [[ ! -e "$path" ]]; then
            warning "Path does not exist: $path"
            continue
        fi
        
        if [[ "$dry_run" == "true" ]]; then
            info "DRY RUN: Would set $path to $perms $owner:$group"
            continue
        fi
        
        chmod "$perms" "$path" 2>/dev/null || warning "Failed to set permissions on $path"
        chown "$owner:$group" "$path" 2>/dev/null || warning "Failed to set ownership on $path"
        success "Fixed permissions: $path"
    done
}

# Full maintenance
full_maintenance() {
    local dry_run="${1:-false}"
    local force="${2:-false}"
    
    banner "=== Full Maintenance Mode ==="
    
    if [[ "$force" != "true" && "$dry_run" != "true" ]]; then
        warning "This will perform full maintenance including service restart"
        read -p "Continue? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            info "Operation cancelled"
            return 0
        fi
    fi
    
    info "Starting full maintenance routine..."
    
    check_config || return 1
    cleanup_logs "$dry_run"
    cleanup_backups "$dry_run"
    optimize_db "$dry_run"
    vacuum_db "$dry_run"
    update_serials "$dry_run"
    check_zones
    repair_permissions "$dry_run"
    
    if [[ "$dry_run" != "true" ]]; then
        restart_service "true"
    fi
    
    success "Full maintenance completed"
}

# Parse arguments
DRY_RUN=false
FORCE=false
VERBOSE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --verbose)
            VERBOSE=true
            set -x
            shift
            ;;
        *)
            break
            ;;
    esac
done

# Main execution
case "${1:-help}" in
    "cleanup-logs")
        cleanup_logs "$DRY_RUN"
        ;;
    "optimize-db")
        optimize_db "$DRY_RUN"
        ;;
    "check-config")
        check_config
        ;;
    "restart-service")
        restart_service "$FORCE"
        ;;
    "update-serials")
        update_serials "$DRY_RUN"
        ;;
    "cleanup-backups")
        cleanup_backups "$DRY_RUN"
        ;;
    "vacuum-db")
        vacuum_db "$DRY_RUN"
        ;;
    "check-zones")
        check_zones
        ;;
    "repair-permissions")
        repair_permissions "$DRY_RUN"
        ;;
    "full-maintenance")
        full_maintenance "$DRY_RUN" "$FORCE"
        ;;
    "help"|*)
        show_usage
        ;;
esac
